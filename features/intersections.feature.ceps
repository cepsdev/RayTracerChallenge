
let skip_summary = 0;
let summary_only_failures = 0;

val p = undef;
val r = undef;
val orig = undef;
val dir = undef;
val sp = undef;
val xs = undef;
val i = undef;
val i1 = undef;
val i2 = undef;
kind DocgenStringPrintNoEscape;
DocgenStringPrintNoEscape docinfo_se;

docinfo_se(

"
"

);

macro equality_test{
   symbolic_equality(as_nodeset(arglist.at(0)),as_nodeset(arglist.at(1))).diff.equal.content();
};


Scenario{
     title{label __chapter__5_scenario_tracking_intersections_1 title = "An intersection encapsulates t and object";};
     Given{
         let sp = rt_obj(sphere{});
     };
     When{let i = rt_obj(intersection{3.5;sp;});};
     Then{
        i.intersection.t.content() == 3.5;
     };
     And{
        equality_test{i.intersection.object.content(); rt_obj(sphere{}); };
     };
};

Scenario{
     title{label __chapter__5_scenario_tracking_intersections_2 title = "Aggregating intersections";};
     Given{
         let sp = rt_obj(sphere{});
     };
     And{let i1 = rt_obj(intersection{1.0;sp;});};
     And{let i2 = rt_obj(intersection{2.0;sp;});};
     When{let xs = rt_obj(intersections{i1;i2;});};
     Then{
        xs.content().size() == 2;
     };
     And{
       equality_test{
         xs.intersections.intersection.at(0);
         intersection{
             t{1.0;};
             object{sphere{};};
         };
       };
     };
     And{
       equality_test{
         xs.intersections.intersection.at(1);
         intersection{
             t{2.0;};
             object{sphere{};};
         };
       };
     };
};

Scenario{
     title{label __chapter__5_scenario_tracking_intersections_3 title = "Intersect sets the object on the intersection";};
     Given{
         let r = rt_obj(
            ray{
               rt_obj(point{0.0;0.0;-5.0;});
               rt_obj(vector{0.0;0.0;1.0;});
            }
         );
     };
     And{let sp = rt_obj(sphere{});};
     When{let xs = rt_op(intersect{sp;r;});};
     Then{
        xs.intersections.intersection.size() == 2;
     };
     And{
       equality_test{
         xs.intersections.intersection.at(0).content().object;
        object{sphere{};};
       };
     };
     And{
       equality_test{
         xs.intersections.intersection.at(1).content().object;
        object{sphere{};};
       };
     };
};